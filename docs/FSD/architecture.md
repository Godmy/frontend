# Feature-Sliced Design Architecture

## Описание архитектуры

Frontend проекта построен на основе архитектурного подхода, вдохновленного методологией Feature-Sliced Design (FSD), с модификациями под потребности проекта.

### Основные принципы

1. **Модульность** - каждый слой изолирован и может развиваться независимо
2. **Переиспользуемость** - компоненты и утилиты должны быть переиспользуемыми
3. **Тестируемость** - архитектура поддерживает написание тестов
4. **Масштабируемость** - проект должен масштабироваться без изменения архитектуры

### Структура проекта

```
src/
├── app/            # Входная точка приложения
├── processes/      # Бизнес-процессы
├── pages/          # Страницы приложения
├── widgets/       # Компоненты уровня виджетов
├── features/      # Функциональные возможности
├── entities/      # Бизнес-сущности
└── shared/        # Общие ресурсы
    ├── ui/         # UI-компоненты по Atomic Design
    ├── api/        # API-утилиты
    ├── lib/        # Библиотеки
    ├── config/     # Конфигурация
    ├── types/      # Типы
    ├── assets/     # Ассеты
    └── utils/      # Утилиты
```

### Назначение слоев

- **app** - точка входа приложения, настройка приложения и обработка основных зависимостей
- **processes** - бизнес-процессы, охватывающие несколько страниц (например, "регистрация нового пользователя")
- **pages** - страницы приложения, соединяющие сущности, возможности и виджеты
- **widgets** - комплексные компоненты, которые отображаются на нескольких страницах (например, шапка, боковая панель)
- **features** - функциональность, связанная с действиями пользователя (например, "авторизация", "создание статьи")
- **entities** - бизнес-сущности с доменной логикой (например, пользователь, статья, комментарий)
- **shared** - переиспользуемые ресурсы без бизнес-логики

### Слои архитектуры

#### 1. Shared (универсальные компоненты)
Расположены в `src/lib/components/` - переиспользуемые компоненты, не зависящие от бизнес-логики:
- Кнопки, инпуты, модальные окна
- Утилиты и переиспользуемые элементы UI

Содержит поддиректории:
- `api/` - общие API клиенты
- `assets/` - общие ресурсы
- `config/` - общие настройки
- `lib/` - общие библиотеки
- `types/` - общие типы TypeScript
- `ui/` - общие UI компоненты
- `utils/` - общие утилиты

#### 2. Entities (сущности приложения)
Расположены в `src/entities/` - компоненты, представляющие бизнес-сущности:
- `Concept` - работа с концепциями
- `Dictionary` - работа со словарями
- `Language` - работа с языками
- `User` - работа с пользователями

#### 3. Features (бизнес-функции)
Расположены в `src/features/` - компоненты, реализующие конкретные бизнес-функции:
- `Auth` - аутентификация и авторизация
- `Search` - поиск по приложению
- `Filter` - фильтрация данных
- `Notification` - уведомления
- `LanguageSwitcher` - переключатель языков

#### 4. Widgets (виджеты)
Расположены в `src/widgets/` - компоненты для сборки полноценных блоков интерфейса:
- `MainNavigation` - главное меню
- `UserProfile` - профиль пользователя
- `ConceptList` - список концепций
- `DictionaryList` - список словарей

#### 5. Pages (страницы)
Расположены в `src/pages/` и `src/routes/` - страницы приложения:
- `Dashboard` - главная панель
- `ConceptsPage` - страница концепций
- `DictionariesPage` - страница словарей
- `LanguagesPage` - страница языков
- `ProfilePage` - страница профиля

## Atomic Design в слое Shared

В слое `shared/ui` мы используем принципы Atomic Design для организации UI-компонентов:

### Структура Atomic Design

```
shared/ui/
├── atoms/          # Базовые компоненты (кнопки, инпуты, лейблы)
├── molecules/      # Комбинации атомов (формы, карточки)
└── organisms/      # Комплексные компоненты (таблицы, навигация и т.д.)
```

### Уровни компонентов

- **Atoms (атомы)** - Наименьшие возможные компоненты: Button, Input, Checkbox, Select, Textarea, Badge, Avatar
- **Molecules (молекулы)** - Комбинации атомов: FormFactory, SearchBar, и другие составные компоненты
- **Organisms (организмы)** - Комплексные компоненты, состоящие из атомов и молекул: Table, Tabs, Accordion и другие

## Совместимость с Houdini

При разработке компонентов для новой архитектуры необходимо учитывать следующие требования совместимости:

1. **Синтаксис Svelte 5**: Использовать только те функции Svelte 5, которые поддерживаются Houdini
2. **Slots**: Использовать традиционный синтаксис `<slot />` вместо новых функций snippets
3. **Reactivity**: Использовать `$:` для реактивных выражений и `bind:` для двустороннего связывания
4. **Props**: Использовать `$props()` для определения props, но с осторожностью

## Настройка проекта

Для использования новой архитектуры добавлен алиас `$shared` в `svelte.config.js`:

```js
alias: {
  $houdini: ".houdini/",
  $shared: "./src/shared"  // Доступ к новому слою shared
}
```

Это позволяет использовать импорты вида:
```js
import { Button } from '$shared/ui';
import { UserApi } from '$shared/api';
```

## Принципы именования файлов

- Используем PascalCase для компонентов: `UserProfile.svelte`
- Используем camelCase для утилит и функций: `formatDate.ts`
- Файлы типов имеют расширение `.types.ts`: `user.types.ts`
- Конфигурационные файлы имеют постфикс `.config.ts`: `api.config.ts`

## Принципы модулей

- Все компоненты экспортируют только один основной элемент
- Для экспорта вспомогательных компонентов используем именованный экспорт
- Каждый модуль имеет clear API и не зависит от других модулей напрямую

## Принципы масштабирования

- Для добавления новой функциональности создаем новую директорию в соответствующем слое
- При необходимости переиспользуем компоненты из слоя `shared`
- Следим за тем, чтобы не было циклических зависимостей между слоями
- Зависимости идут только от более высоких слоев к более низким

## Примеры структуры

### Пример сущности (entity)

```
entities/user/
├── model/          # Типы, интерфейсы
│   └── types.ts    # Определения типов User
├── api/            # API-запросы
│   └── api.ts      # Функции для работы с API пользователей
├── lib/            # Вспомогательные функции
│   └── utils.ts    # Вспомогательные утилиты
├── ui/             # UI-компоненты, связанные с пользователем
│   └── UserCard.svelte
└── index.ts        # Публичный API сущности
```

### Пример возможности (feature)

```
features/auth/
├── model/          # Состояние аутентификации
│   └── store.ts    # Store для состояния аутентификации
├── api/            # API-функции аутентификации
│   └── auth-api.ts # Функции для входа/выхода
├── lib/            # Вспомогательные функции
│   └── guards.ts   # Защиты доступа
├── ui/             # Компоненты аутентификации
│   └── LoginForm.svelte
└── index.ts        # Публичный API возможности
```

### Пример виджета (widget)

```
widgets/header/
├── model/          # Состояние виджета
├── ui/             # Компоненты виджета
│   └── Header.svelte
└── index.ts        # Публичный API виджета
```

## Правила импортов

- Импорты внутри одного слоя: `import { SomeComponent } from './SomeComponent.svelte'`
- Импорты из слоя `shared`: `import { Button } from '$shared/ui'`
- Импорты из других слоев: `import { User } from '$entities/user'`
- Не используем относительные импорты для слоев FSD (например, `../../../shared/ui`)

## Основные компоненты

### Auth компоненты
- `LoginForm.svelte` - форма входа
- `RegisterForm.svelte` - форма регистрации
- `ProtectedRoute.svelte` - защищенный маршрут
- `RequirePermission.svelte` - проверка прав доступа
- `RequireRole.svelte` - проверка роли

### UI компоненты
- `Toast.svelte` - уведомления
- `ToastContainer.svelte` - контейнер для уведомлений
- Формы с валидацией с использованием Zod
- Компоненты для отображения данных (например, дерево концепций)

## Система типов

Проект использует строгую типизацию через TypeScript и автоматическую генерацию типов из GraphQL схемы с помощью Houdini:
- Все GraphQL запросы и мутации типизированы
- Типы генерируются автоматически из схемы backend
- Валидация форм с использованием Zod

## Уведомления (Notifications)

Система уведомлений построена с использованием Svelte 5 Runes:
- `notificationStore.svelte.ts` - store для управления уведомлениями
- Поддерживает 4 типа: success, error, warning, info
- Автоматическое закрытие
- Поддержка действий (callbacks)
- Интеграция с системой обработки ошибок

## Обработка ошибок

Централизованная система обработки ошибок:
- `AppError.ts` - базовый класс типизированных ошибок
- `ErrorHandler.ts` - централизованный обработчик
- Интеграция с системой уведомлений
- Поддержка различных типов ошибок: network, validation, authentication, authorization, not_found, server, unknown

## GraphQL и Houdini

Проект использует Houdini для работы с GraphQL:
- Автогенерация TypeScript типов
- Кеширование запросов (CacheAndNetwork по умолчанию)
- Оптимистичные обновления
- Директивы (@list для автоматического обновления списков)

## Тестирование

### Unit тесты
- Используется Vitest
- Покрытие кода 80%+
- Тесты для бизнес-логики и компонентов

### E2E тесты
- Используется Playwright
- Тестирование пользовательских сценариев

## Безопасность

- Проверка ролей и разрешений
- Защита маршрутов
- Безопасное хранение токенов
- Защита от CSRF и XSS атак

## Мультиязычность

- Поддержка фильтрации контента по языкам
- Автоматическое сохранение выбора языка
- Интеграция с системой уведомлений

## Преимущества новой архитектуры

1. **Четкая структура**: Логика приложения разбита по слоям, что облегчает навигацию
2. **Масштабируемость**: Новая функциональность легко добавляется в соответствующий слой
3. **Переиспользуемость**: Компоненты и утилиты из слоя `shared` могут использоваться по всему приложению
4. **Изолированность**: Каждый слой изолирован от других, что уменьшает влияние изменений
5. **Понятность**: Структура интуитивно понятна новым разработчикам

## Рекомендации по разработке

1. **Начинайте с простого**: При создании новых компонентов начинайте с простого синтаксиса
2. **Проверяйте совместимость**: Убедитесь, что новые компоненты совместимы с Houdini
3. **Используйте проверенные паттерны**: Следуйте проверенным паттернам Svelte
4. **Тестируйте постепенно**: Добавляйте функциональность постепенно и проверяйте сборку

## Ссылки

- [Официальный сайт Feature-Sliced Design](https://feature-sliced.design/)
- [Официальный сайт Atomic Design](http://bradfrost.com/blog/post/atomic-web-design/)
- [Документация Svelte](https://svelte.dev/docs)
- [Документация TypeScript](https://www.typescriptlang.org/docs/)
- [Документация Houdini](https://houdinigraphql.com/)