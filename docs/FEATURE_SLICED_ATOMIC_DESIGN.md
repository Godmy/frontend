# Feature-Sliced Design и Atomic Design архитектура

## Обзор

Этот документ описывает внедрение архитектурных паттернов Feature-Sliced Design (FSD) и Atomic Design в проект Multipult Frontend с учетом совместимости с Houdini GraphQL фреймворком. Новая архитектура обеспечивает лучшую масштабируемость, поддерживаемость и понятность кодовой базы.

## Особенности реализации

**Важно**: При реализации новой архитектуры необходимо учитывать следующие ограничения:
- Использование синтаксиса Svelte 5 должно быть совместимо с Houdini
- Новые функции Svelte 5 (например, snippets) могут потребовать альтернативной реализации
- Все компоненты должны использовать проверенный синтаксис, совместимый с текущей версией Svelte и Houdini

## Feature-Sliced Design

Feature-Sliced Design (FSD) - это архитектурный подход, который разделяет приложение на независимые слои, каждый из которых отвечает за определенную функциональность.

### Структура проекта

```
src/
├── app/            # Входная точка приложения
├── processes/      # Бизнес-процессы
├── pages/          # Страницы приложения
├── widgets/       # Компоненты уровня виджетов
├── features/      # Функциональные возможности
├── entities/      # Бизнес-сущности
└── shared/        # Общие ресурсы
    ├── ui/         # UI-компоненты по Atomic Design
    ├── api/        # API-утилиты
    ├── lib/        # Библиотеки
    ├── config/     # Конфигурация
    ├── types/      # Типы
    ├── assets/     # Ассеты
    └── utils/      # Утилиты
```

### Назначение слоев

- **app** - точка входа приложения, настройка приложения и обработка основных зависимостей
- **processes** - бизнес-процессы, охватывающие несколько страниц (например, "регистрация нового пользователя")
- **pages** - страницы приложения, соединяющие сущности, возможности и виджеты
- **widgets** - комплексные компоненты, которые отображаются на нескольких страницах (например, шапка, боковая панель)
- **features** - функциональность, связанная с действиями пользователя (например, "авторизация", "создание статьи")
- **entities** - бизнес-сущности с доменной логикой (например, пользователь, статья, комментарий)
- **shared** - переиспользуемые ресурсы без бизнес-логики

## Atomic Design

В слое `shared/ui` мы используем принципы Atomic Design для организации UI-компонентов:

### Структура Atomic Design

```
shared/ui/
├── atoms/          # Базовые компоненты (кнопки, инпуты, лейблы)
├── molecules/      # Комбинации атомов (формы, карточки)
└── organisms/      # Комплексные компоненты (таблицы, навигация и т.д.)
```

### Уровни компонентов

- **Atoms (атомы)** - Наименьшие возможные компоненты: Button, Input, Checkbox, Select, Textarea, Badge, Avatar
- **Molecules (молекулы)** - Комбинации атомов: FormFactory, SearchBar, и другие составные компоненты
- **Organisms (организмы)** - Комплексные компоненты, состоящие из атомов и молекул: Table, Tabs, Accordion и другие

## Настройка проекта

Для использования новой архитектуры добавлен алиас `$shared` в `svelte.config.js`:

```js
alias: {
  $houdini: ".houdini/",
  $shared: "./src/shared"  // Доступ к новому слою shared
}
```

Это позволяет использовать импорты вида:
```js
import { Button } from '$shared/ui';
import { UserApi } from '$shared/api';
```

## Совместимость с Houdini

При разработке компонентов для новой архитектуры необходимо учитывать следующие требования совместимости:

1. **Синтаксис Svelte 5**: Использовать только те функции Svelte 5, которые поддерживаются Houdini
2. **Slots**: Использовать традиционный синтаксис `<slot />` вместо новых функций snippets
3. **Reactivity**: Использовать `$:` для реактивных выражений и `bind:` для двустороннего связывания
4. **Props**: Использовать `$props()` для определения props, но с осторожностью

## Принципы именования файлов

- Используем PascalCase для компонентов: `UserProfile.svelte`
- Используем camelCase для утилит и функций: `formatDate.ts`
- Файлы типов имеют расширение `.types.ts`: `user.types.ts`
- Конфигурационные файлы имеют постфикс `.config.ts`: `api.config.ts`

## Принципы модулей

- Все компоненты экспортируют только один основной элемент
- Для экспорта вспомогательных компонентов используем именованный экспорт
- Каждый модуль имеет clear API и не зависит от других модулей напрямую

## Принципы масштабирования

- Для добавления новой функциональности создаем новую директорию в соответствующем слое
- При необходимости переиспользуем компоненты из слоя `shared`
- Следим за тем, чтобы не было циклических зависимостей между слоями
- Зависимости идут только от более высоких слоев к более низким

## Примеры структуры

### Пример сущности (entity)

```
entities/user/
├── model/          # Типы, интерфейсы
│   └── types.ts    # Определения типов User
├── api/            # API-запросы
│   └── api.ts      # Функции для работы с API пользователей
├── lib/            # Вспомогательные функции
│   └── utils.ts    # Вспомогательные утилиты
├── ui/             # UI-компоненты, связанные с пользователем
│   └── UserCard.svelte
└── index.ts        # Публичный API сущности
```

### Пример возможности (feature)

```
features/auth/
├── model/          # Состояние аутентификации
│   └── store.ts    # Store для состояния аутентификации
├── api/            # API-функции аутентификации
│   └── auth-api.ts # Функции для входа/выхода
├── lib/            # Вспомогательные функции
│   └── guards.ts   # Защиты доступа
├── ui/             # Компоненты аутентификации
│   └── LoginForm.svelte
└── index.ts        # Публичный API возможности
```

### Пример виджета (widget)

```
widgets/header/
├── model/          # Состояние виджета
├── ui/             # Компоненты виджета
│   └── Header.svelte
└── index.ts        # Публичный API виджета
```

## Правила импортов

- Импорты внутри одного слоя: `import { SomeComponent } from './SomeComponent.svelte'`
- Импорты из слоя `shared`: `import { Button } from '$shared/ui'`
- Импорты из других слоев: `import { User } from '$entities/user'`
- Не используем относительные импорты для слоев FSD (например, `../../../shared/ui`)

## Преимущества новой архитектуры

1. **Четкая структура**: Логика приложения разбита по слоям, что облегчает навигацию
2. **Масштабируемость**: Новая функциональность легко добавляется в соответствующий слой
3. **Переиспользуемость**: Компоненты и утилиты из слоя `shared` могут использоваться по всему приложению
4. **Изолированность**: Каждый слой изолирован от других, что уменьшает влияние изменений
5. **Понятность**: Структура интуитивно понятна новым разработчикам

## Рекомендации по разработке

1. **Начинайте с простого**: При создании новых компонентов начинайте с простого синтаксиса
2. **Проверяйте совместимость**: Убедитесь, что новые компоненты совместимы с Houdini
3. **Используйте проверенные паттерны**: Следуйте проверенным паттернам Svelte
4. **Тестируйте постепенно**: Добавляйте функциональность постепенно и проверяйте сборку

## Ссылки

- [Официальный сайт Feature-Sliced Design](https://feature-sliced.design/)
- [Официальный сайт Atomic Design](http://bradfrost.com/blog/post/atomic-web-design/)
- [Документация Svelte](https://svelte.dev/docs)
- [Документация TypeScript](https://www.typescriptlang.org/docs/)
- [Документация Houdini](https://houdinigraphql.com/)